# LeetCode-Python-Java

zhouzhenping/LeetCode-Python&amp;Java

---

## 参考代码来源

1. 力扣（LeetCode）
链接：<https://leetcode-cn.com>  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
2. Github <https://github.com/strengthen/LeetCode.git>

---

### 01 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
|示例:|
|:-|
|给定 nums = [2, 7, 11, 15], target = 9|
|因为 nums[0] + nums[1] = 2 + 7 = 9|
|所以返回 [0, 1]|

### 02 两数相加

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
|示例|
|:-|
|输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)|
|输出：7 -> 0 -> 8|
|原因：342 + 465 = 807|

### 07 整数反转

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

|||
|:---|:---|
|示例 1|输入: 123<br/>输出：321|
|示例 2|输入: -123<br/> 输出: -321|
|示例 3|输入: 120<br/>输出: 21|
  
### 09 回文数  

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  
你能不将整数转为字符串来解决这个问题吗？  

|||
|:---|:---|
|示例 1|输入: 121<br/>输出: true|
|示例 2|输入: -121<br/>输出: false<br/>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。|
|示例 3|输入: 10<br/>输出: false<br/>解释: 从右向左读, 为 01 。因此它不是一个回文数。  

方法：反转一半数字
思路

映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。

第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。
但是，如果反转后的数字大于 \text{int.MAX}int.MAX，我们将遇到整数溢出问题。
按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。
例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。  
让我们看看如何将这个想法转化为一个算法。
算法  
首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。
现在，让我们来考虑如何反转后半部分的数字。
对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。
现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？
我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。

### 13 罗马数字转整数
https://leetcode-cn.com/problems/roman-to-integer/
首先将所有的组合可能性列出并添加到哈希表中
然后对字符串进行遍历，由于组合只有两种，一种是 1 个字符，一种是 2 个字符，其中 2 个字符优先于 1 个字符
先判断两个字符的组合在哈希表中是否存在，存在则将值取出加到结果 ans 中，并向后移2个字符。不存在则将判断当前 1 个字符是否存在，存在则将值取出加到结果 ans 中，并向后移 1 个字符
遍历结束返回结果 ans

### 14 最长公共前缀
https://leetcode-cn.com/problems/longest-common-prefix/
